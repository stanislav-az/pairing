-- https://github.com/adjoint-io/pairing/tree/0.3.1
module Main where

import Protolude

import Pairing.Group
import Pairing.CyclicGroup
import Pairing.Pairing
import Pairing.Point
import Pairing.Fr (Fr(..))
import Pairing.Fq (Fq(..))
import Pairing.Fq2 (Fq2(..))
import Pairing.Fq12 (Fq12(..), fq12one)

data VerificationKey = VerificationKey {
    vkAlfa1 :: G1
  , vkBeta2 :: G2
  , vkGamma2 :: G2
  , vkDelta2 :: G2
  , vkIC :: [G1]
  }
  deriving (Eq, Show)

data Proof = Proof {
    proofA :: G1
  , proofB :: G2
  , proofC :: G1
  }
  deriving (Eq, Show)

verificationKey :: VerificationKey
verificationKey = VerificationKey {
    vkAlfa1 = Point
        (Fq 3519983779875975884833669322644459063638450737909635765863865541872816858376)
        (Fq 7397099103576276514295477589558878626884885290877914840485004796772491333406)
  , vkBeta2 = Point
        (Fq2
         (Fq 4055210887597267573862197659315373416864928047670163988706273513208955750759)
         (Fq 4233108826603850015763960594754484752349032325245460126061176201699088355723)
        )
        (Fq2
         (Fq 10734055131721991386361548026072880619041664090603612227306479935970068384429)
         (Fq 15529181653007204823676300510451171809392982039264354999549976792049587936261)
        )
  , vkGamma2 = Point
        (Fq2
         (Fq 10857046999023057135944570762232829481370756359578518086990519993285655852781)
         (Fq 11559732032986387107991004021392285783925812861821192530917403151452391805634)
        )
        (Fq2
         (Fq 8495653923123431417604973247489272438418190587263600148770280649306958101930)
         (Fq 4082367875863433681332203403145435568316851327593401208105741076214120093531)
        )
  , vkDelta2 = Point
        (Fq2
         (Fq 5795067521892209664508696230815993254066313192442331467455306988810762153656)
         (Fq 15150465902568040861568244142756230434811118386935944114889784614870630155655)
        )
        (Fq2
         (Fq 17887064173843031597393549322152319283014342519900457086032146517880793360891)
         (Fq 13471038907510548380069206393375488516383307496487161396960211476483925790387)
        )
  , vkIC = [
        Point
          (Fq 12205800145834954087629756830011671649884585767932945027040922596370775575027)
          (Fq 12335909711281406674675777935087685643547480208328236512555693568331448637030)
      , Point
          (Fq 11642085884811769906577990096315880343230600233455728567642797818737321267166)
          (Fq 1194068800058154376479103256936875836563891942409976760453620908437570741987)
      , Point
          (Fq 15302762551311403468794223356053351955569213123927590593607892781770420932216)
          (Fq 17341761658547253261341398665768411153995274800232623766938021005739128393935)
      , Point
          (Fq 11905519547163994483317077345000487664106200643027117393662431849423582259559)
          (Fq 17271392723818383815489974533793402703707209079397780140640476271182126349938)
      , Point
          (Fq 11103214678582990427796680142068148646644353914344094476356909773699253567150)
          (Fq 20438733183586278340783911095605163119833027156590827692550246152785709634466)
      , Point
          (Fq 1692776111806236653550976737571686296292047956215055404352758934926723275222)
          (Fq 3866854602724290522517283948294183629491075037104265397972296743285697658046)
  ]
  }

proof :: Proof
proof = Proof {
    proofA = Point
        (Fq 10667518109631873717779227851225360355588812947382209800535554255096971096483)
        (Fq 20305424707620899269117899498049728680005573275881622071465503930450006304536)
  , proofB = Point
        (Fq2
         (Fq 13543236916852503823109077844928640539579148394480853320321709298057000320602)
         (Fq 16448137712173626880831157194924329280353892421001498387960910233585321361659)
        )
        (Fq2
         (Fq 14735949475970649242021073124954932476234639192529709156514846786329435615309)
         (Fq 8666417887188242965449366185810518869037821547934658604409010658311515645498)
        )
  , proofC = Point
        (Fq 1376035243905502547553743716366476967918715079206281236926733687790025045608)
        (Fq 15618283849217480282851859927327045424169838580560639102425714418180761229251)
  }

input :: [Fr]
input = [
    239800306750427551869236616192506438318941364276244034862145737470436703881
  , 221602709552812918224846683815139171692327784459685931639213360097642718917
  , 789
  , 456
  , 123
  ]

mkVkX :: [Fr] -> [G1] -> G1
mkVkX input ic = fold $ zipWith expn ic $ 1 : input

mkVerifyProof :: VerificationKey -> [Fr] -> Proof -> GT
mkVerifyProof VerificationKey{..} input Proof{..} = reducedPairing (inverse proofA) proofB <>
        reducedPairing vkAlfa1 vkBeta2 <>
        reducedPairing vkX vkGamma2 <>
        reducedPairing proofC vkDelta2
  where
    vkX = mkVkX input vkIC

main :: IO ()
main  = do
  putText "isOnCurve sanity check:"
  print (isOnCurveG1 $ proofA proof)
  print (isOnCurveG2 $ proofB proof)
  print (isOnCurveG1 $ proofC proof)
  print (isOnCurveG1 $ vkAlfa1 verificationKey)
  print (isOnCurveG2 $ vkBeta2 verificationKey)
  print (isOnCurveG2 $ vkGamma2 verificationKey)
  print (isOnCurveG2 $ vkDelta2 verificationKey)
  print (all isOnCurveG1 $ vkIC verificationKey)
  putText "pairing:"
  let p = mkVerifyProof verificationKey input proof
  print p
  print (p == fq12one)
